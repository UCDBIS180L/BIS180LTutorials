---
title: "ggplot tutorial"
tutorial:
  version: 1.0
output: 
  learnr::tutorial:
    progressive: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(tidyverse)
library(learnr)
tomato <- read_csv("www/Tomato.csv")
tomatoH <- tomato %>% filter(trt=="H")
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
```


## ggplot

### ggplot intro

The [ggplot2](http://ggplot2.org) package is a package that allows you to rapidly make impressive plots from complex data sets.

In addition to this tutorial there are several excellent resources available on the web:

* The visualization chapter of [R for Data Science](http://r4ds.had.co.nz/data-visualisation.html)
* The Graphs section of [Cookbook for R](http://www.cookbook-r.com/Graphs/) (highly recommended! Especially good when you have a "how do I..." type of question)
* The official [ggplot documentation](http://ggplot2.tidyverse.org/reference/)

ggplot is part of the tidyverse, so let's load that library
```{r tidyverse, exercise = TRUE}
library(tidyverse)
```
(You can also just use `library(ggplot2)` if you don't want/need the other tidyverse packages)

### A first plot

We again work with the Tomato data set.  It has been preloaded for this tutorial.  To remind you, it has the following columns: 

* shelf, flat, col, row: information about where each plant was grown
* acs: the accession number for that strain
* trt: "H" is light with a high red:far\-red ratio; simulated sun.  "L" is light with a low red:far\- red ratio; simulated plant shade.
* days: days since germination
* date: date of measurement
* hyp: hypocotyl length (embryonic stem)
* int1-int4: individual internode lengths. Internodes are stem segments
* leafnum: which leaf was measured
* petleng: petiole length
* leafleng: leaf length
* leafwid: leaf width
* ndvi: a measure of plant vegetation density
* lat: latitude of origin
* long: longitude of origin
* alt: altitude of origin
* species: species of plant
* who: who measured the plants

I have also created a reduced data set, `tomatoH` that only contains measurements from the "H" treatment.
```{r head, exercise=TRUE}
head(tomatoH)
```

Let us begun by asking if there is a relationship between the length of the petiole (leaf stem) and the leaf of the leaf blade:

```{r firstplot, exercise=TRUE}
ggplot(data=tomato, 
       mapping = aes(x=petleng,y=leafleng)) +
  geom_point()
```

Yes, it looks like there is.  

Let's look at each line of the code above:

* `ggplot(data=tomato, ` ggplot is the main function and initiates the plot.  The data argument tells ggplot what data set to work on.
* `mapping = aes(x=petleng,y=leafleng) + ` Here we are telling ggplot which columns in our data set should be mapped to particular plot __aes__thetics.  The argument is called `mapping` and the input to mapping is the `aes()` function.  We use `aes()` to tell ggplot that petiole length should be mapped to the x axis and leaf length should be mapped to the y axis.
* notice that the line that beings with `mapping` ends with a `+` .  This tells R that we want to add to the plot created by the ggplot function.
* `geom_point()`.  Geoms (geometries) indicate what what type of plot we want to make.

We will look at these functions in more detail as the tutorial continues...

Note that since we loaded tidyverse we could also pipe our data into ggplot:

```{r pipe2ggplot, exercise=TRUE}
tomato %>% ggplot(mapping = aes(x=petleng,y=leafleng)) +
  geom_point()
```



## Aesthetics

In this section we will explore aesthetics.  As noted above, aesthetics control the relationship between your data and plot elements.

### color

One common aesthetic is the `color` aesthetic.  Change the code below so that color is mapped to the treatment (`trt`) column:

```{r color, exercise=TRUE}
tomato %>% ggplot(mapping = aes(x=petleng,y=leafleng)) +
  geom_point()
```

### shape

The `shape` aesthetic controls the shape of the plotted points.  

Create a plot of int3 vs int4 where color indicates trt, and shape indicates who measured the plant.

```{r shape-color, exercise=TRUE}

```

### size

The `size` aesthetic controls the size of the plotted points.

To practice, create a plot of latitude vs longitude where altitude is indicated by the size of the point and species is indicated by color

```{r size, exercise = TRUE}

```

### setting plot characteristics without mapping

What if you want to change a plot characteristic but not have it mapped to a data column?  You can do this by setting the characteristic in the gome call, but outside of the `aes` function:

```{r color2, exercise=TRUE}
tomato %>% ggplot(mapping = aes(x=petleng,y=leafleng)) +
  geom_point(color="skyblue")
```

The different plotting shapes are numbered from 0 to 25.  Change the code below to use shape 2 (do not use quotes around the 2).  Feel free to explore the other shapes.
```{r shape2, exercise=TRUE}
tomato %>% ggplot(mapping = aes(x=petleng,y=leafleng)) +
  geom_point(color="skyblue")
```

### more aesthetics

There are many more aesthetics available, depending on the geom used.  Some of these will be introduced as you learn about additional geoms.

## Geoms

Geoms control the type of plot that is made.  You have already seen one geom, `geom_point`.

### geom_smooth()

`geom_smooth` allows you to add trend lines to your plots, for example:

```{r smooth, exercise = TRUE}
tomato %>% ggplot(aes(x=lon, y = lat)) + 
  geom_smooth()
```

But wait, what if you also want the original data points?  We can add multiple geoms to a plot:

```{r smooth-point, exercise = TRUE}
tomato %>% ggplot(aes(x=lon, y = lat)) + 
  geom_smooth() +
  geom_point()
```

By default geom_smooth fits a smoothed line to the data.  But you can also show a best-fit, straight linear regression.  To do this we tell geom_smooth to use the "lm" (linear model) function:

```{r smooth2, exercise = TRUE}
tomato %>% ggplot(aes(x=lon, y = lat)) + 
  geom_smooth(method="lm") +
  geom_point()
```

Try including a trend-line to the plot of int3 vs int4.  Does the order of geom_smooth and geom_point matter in the final output of the plot?

```{r smooth-order, exercise = TRUE}

```

### geom_histogram() and geom_density()

`geom_histogram()` creates histograms.  For histograms, values for the y-axis are calculated for you, so we just provide a x aesthetic:

```{r geom_hist1, exercise=TRUE}
tomato %>% ggplot(aes(x=hyp)) +
  geom_histogram()
```

Histograms (and many other plots) can use the `fill` aesthetic to control the color used to fill the bars (or other shapes).

```{r geom_hist1-fill, exercise=TRUE}
tomato %>% ggplot(aes(x=hyp)) +
  geom_histogram(fill="red")
```

Density plots are related to histograms. The relevant geom is `geom_density()`.  Make a density plot below:
```{r geom_density, exercise=TRUE}

```

How would you describe the difference between a density plot and a histogram?

One nice thing about density plots is that we can compare the densities of different subsets of the data:

```{r geom_density-fill, exercise=TRUE}
tomato %>% ggplot(aes(x=hyp, fill=trt)) +
  geom_density(alpha=.5)
```

What is alpha doing?  Experiment with different values; the allowable range is 0 to 1.

```{r geom_density-fill-alpha, exercise=TRUE}
tomato %>% ggplot(aes(x=hyp, fill=trt)) +
  geom_density(alpha=.5)
```

Alpha can be used in most geoms.

### geom_boxplot() and geom_violin()

Boxplots and violin plots are provide quick summaries of different classes of data.  Suppose we want to examine hypocotyl length of each species.  We can map hypocotyl length to the y-axis and species to the x-axis.

```{r geom_box, exercise=TRUE}
tomato %>% ggplot(aes(x=species, y=hyp)) +
  geom_boxplot()
```

In a boxplot the horizontal line represents the median.  Look at the help for geom_boxplot to determine what other components represent:

```{r quiz}
quiz(
  question("What does the 'box' represent?",
    answer("the mean +/- the standard error of the mean"),
    answer("the median +/- the standard deviation"),
    answer("the data between the 25th and 75th percentile", correct = TRUE),
    answer("all the data")
  ),
  question("How far do the 'whiskers' extend?",
    answer("to the 95% confidence interval"),
    answer("to the standard error of the mean"),
    answer("to all of the data"),
    answer("to the furthest data point within 1.5 X the interquartile range", correct = TRUE)
  ),
  question("What to the individual points represent?",
           answer("planets"),
           answer("likely error data points"),
           answer("data points falling outside of 1.5 X the interquartile range", correct = TRUE)
  )
)
```

A related geom is geom_violin()

Remake the above plot using geom_violin.

```{r violin, exercise=TRUE}

```

* Do you like the box or violin plot better?
* What does the width of the "violin" represent?
* Which is more informative about the distribution of the data?

Test your skills

Make a boxplot showing hypocotyl length for the "H" and "L" treatments
```{r box2, exercise=TRUE}

```

### more geom_boxplot()

If we add a color or fill aesthetic to a box or violin plot then we can start comparing multiple factors in our data.

Use the coding box below to re-create this plot:

```{r, warning=FALSE}
tomato %>% ggplot(aes(x=species, y = int3, fill = trt)) +
  geom_boxplot()
```

```{r box-fill, exercise = TRUE}

```

What does this plot illustrate?

### geom_col()

`geom_col()` allows you to make a classic bar chart, where the height of the bars corresopnds to some value in the data.  This works best for data summaries.

First let's summarize our data:

```{r, echo=TRUE}
sem <- function(x, na.rm=FALSE) {
  sd(x,na.rm=na.rm)/sqrt(length(na.omit(x)))
}

int3.mean.sem <- tomato %>%
  group_by(species, trt) %>%
  summarize(mean=mean(int3, na.rm=TRUE), sem=sem(int3, na.rm=TRUE))

int3.mean.sem
```

```{r col1, exercise}
int3.mean.sem %>% ggplot(aes(x=species, y = mean, fill=trt)) +
  geom_col()
```

by default geom_col stacks the columns...perhaps not what we want.  We can change that with `position`

```{r col1, exercise}
int3.mean.sem %>% ggplot(aes(x=species, y = mean, fill=trt)) +
  geom_col(position="dodge")
```

what if we want to add error bars?  we use `geom_errorbar` and the ymin and max aesthetics

```{r col1, exercise=TRUE}
int3.mean.sem %>% ggplot(aes(x=species, y = mean, fill=trt, ymax=mean+sem, ymin=mean-sem)) +
  geom_col(position="dodge") +
  geom_errorbar(position = position_dodge(width=0.9), width=.5)
```

Your turn...

Make a bar chart that shows average leaf length for each accession (acs) and trt combination.

```{r bar-practice, exercise=TRUE}

```

### geom_line

data appropriate for bar charts also can be plotted using lines:

```{r line1, exercise=TRUE}
int3.mean.sem %>% ggplot(aes(x=species,
                             y=mean,
                             color=trt,
                             group=trt,
                             shape=trt,
                             ymax=mean+sem,
                             ymin=mean-sem)) +
  geom_line() +
  geom_errorbar(width=.1) +
  geom_point()
```

It actually doesn't make a lot of sense to plot this data that way.  However, plotting each species' reaction to the treatment would.  Modify the above code to make this plot:

```{r line2}
int3.mean.sem %>% ggplot(aes(x=trt,
                             y=mean,
                             color=species,
                             group=species,
                             shape=species,
                             ymax=mean+sem,
                             ymin=mean-sem)) +
  geom_line() +
  geom_point()
```

```{r line3, exercise=TRUE}

```


### more geoms

There are several more geoms available.  You can [check the docs](http://ggplot2.tidyverse.org/reference/#section-layer-geoms) to see a listing.


## Scales

## Facets

## Titles and Labels

## Saving plots 

ggsave

## Additional Resources



